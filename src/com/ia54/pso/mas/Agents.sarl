package com.ia54.pso.mas

import com.ia54.pso.test.util.Solution
import com.ia54.pso.test.util.Vector2f
import io.sarl.core.AgentTask
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.InnerContextAccess
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import io.sarl.util.Scopes
import java.util.ArrayList
import java.util.Random
import java.util.UUID
import javafx.beans.property.FloatProperty
import javafx.beans.property.SimpleFloatProperty
import javafx.scene.shape.Rectangle

agent BootAgent {
	uses DefaultContextInteractions, Logging

	var mainFrame : MainFrame

	var nbSwarm : Integer

	var adressesSwarm : ArrayList<UUID> = new ArrayList();

	on Initialize {
		info("Boot awake !")
		
		mainFrame = occurrence.parameters.get(0) as MainFrame;
		nbSwarm = MainFrame.NB_SWARM;

		for (var i = 0; i < nbSwarm; i++) {
			adressesSwarm.add(
				spawn(Swarm, mainFrame.particleBodys, MainFrame.WIDTH, MainFrame.HEIGHT, MainFrame.NB_LINES,
					MainFrame.NB_PARTICLES_PER_LINES))
		}

	}
	
	on GetValue {
		var value = MainFrame.FUNCTION.applyAsDouble(occurrence.x, occurrence.y)
		emit(
			new ReturnedValue(new Solution(occurrence.x, occurrence.y, value)), 
			Scopes.addresses(occurrence.source)
		)
	}

//	on GetValue {
//		var value = (MainFrame.FUNCTION as FunctionPSO).applyAsDouble(occurrence.x, occurrence.y);
//		emit(new ReturnedValue(new Solution(occurrence.x, occurrence.y, value), occurrence.source))
//	}

}

agent Swarm {
	uses DefaultContextInteractions, Logging

	var bestSolution : Solution

	var particleSpawned = 0
	var maxParticle = 0
	
	var particles = new ArrayList<UUID>()
	var waitingForMove = new ArrayList<UUID>()
	
	on Initialize {
		info(this.ID + ": Swarm Awake")

		var nblines = occurrence.parameters.get(3) as Integer
		var nbcolumns = occurrence.parameters.get(4) as Integer
		var bodys = occurrence.parameters.get(0) as ArrayList<Rectangle>
		var xStep = (occurrence.parameters.get(1) as Float) / nbcolumns
		var yStep = (occurrence.parameters.get(2) as Float) / nblines

		this.maxParticle = nblines * nbcolumns

		for (var i = 0; i < nblines; i++) {
			for (var j = 0; j < nbcolumns; j++) {
				particles.add(spawn(Particles, bodys.get((i * nbcolumns) + j), xStep * j, yStep * i, this.ID))
			}
		}
	}
	
	on ParticleSpawned{
			
			emit(new StartCycle, Scopes.addresses(occurrence.source))
	}
	
	on OptimumLocalFound {
		if (bestSolution == null) {
			bestSolution = occurrence.solution
			
			emit(new GlobalOptimumFound(bestSolution))
		} else if (occurrence.solution < bestSolution) {
			bestSolution = occurrence.solution

			emit(new GlobalOptimumFound(bestSolution))			
		} else {
			emit(new WaitForMove, Scopes.addresses(occurrence.source))
		}
	}
	
	on AskForMove {
		if(!waitingForMove.contains(occurrence.ID)) {
			waitingForMove.add(occurrence.ID)
		}
		
		if (waitingForMove.size == maxParticle) {
			emit(new AutoriseToMove)	
		}
	}
	
//	on OptimumLocalFound {
//		// on reception of a new optimum, the Holon checks if it is a global optimum:
//		if (solutionHolon == null) {
//			solutionHolon = occurrence.sol
//		} else if (occurrence.sol.value > solutionHolon.value) {
//			info(
//				"Optimum Local Found at x:" + occurrence.sol.getX + ", y:" + occurrence.sol.getY +
//					" and the value is:" +
//					occurrence.sol.value)
//			solutionHolon = occurrence.sol;
//			emit(new GlobalOptimumFound(solutionHolon))
//		}
//
//	}
//
//	on ParticleSpawned {
//		particleSpawned++
//
//		if (particleSpawned == maxParticle) {
//			emit(new StartLive())
//			particleSpawned = 0
//		}
//	}

}

agent Particles {
	uses DefaultContextInteractions, Logging, InnerContextAccess, Lifecycle, Schedules

	var adressSwarm : UUID
	var x : FloatProperty
	var y : FloatProperty

	var ownBestSolution : Solution
	var swarmBestSolution : Solution

	var currentVelocity : Vector2f
	val inertie : Float = 0.5f

	val phi1 = 0.5f
	val phi2 = 0.5f

	val random : Random = new Random()
	
	var waitTask : AgentTask

	on Initialize {
		
		if (occurrence.parameters.isEmpty) {
			info("Empty parameters")
		} else {
			info("Spawn")
			//Bind coordinates to bodys in frame.
			x = new SimpleFloatProperty(occurrence.parameters.get(1) as Float)
			y = new SimpleFloatProperty(occurrence.parameters.get(2) as Float)

			var body = occurrence.parameters.get(0) as Rectangle
			body.xProperty.bind(x)
			body.yProperty.bind(y)

			adressSwarm = occurrence.parameters.get(3) as UUID
			
			currentVelocity = new Vector2f(random.nextFloat * 10, random.nextFloat * 10)
		}
		
		//emit spawn event until it receive a response.
		this.waitTask = task(this.ID + " :  wait_task")
		this.waitTask = task(this.ID + " :  wait_move")
		
		waitTask.every(1000) [
			emit(new ParticleSpawned(this.ID))
			info("want to start cycle !")
		]
	}
	
	on StartCycle {
		info("Cycle started")
		waitTask.cancel()
		waitTask.every(1000)[
			info("Want to get value")
			emit(new GetValue(this.x.value, this.y.value))
		]
	}
	
	on ReturnedValue {
		waitTask.cancel()
		info("Value returned")
		//Check if there is a best solution or not
		if(ownBestSolution == null) {
			ownBestSolution = occurrence.solution
			
			//emit that optimum is found
			waitTask.every(1000) [
				info("Find an optimum !")
				emit(new OptimumLocalFound(ownBestSolution))
			]
		} else if (occurrence.solution < ownBestSolution) {
			ownBestSolution = occurrence.solution

			//emit that optimum is found
			waitTask.every(1000) [
				info("Find an optimum !")
				emit(new OptimumLocalFound(ownBestSolution))
			]
		} else {
			waitTask.every(1000) [
				info("Wait for move!")
				emit(new AskForMove(this.ID))
			]
		}
	}
	
	on GlobalOptimumFound {
		waitTask.cancel()
		
		info("New Global Optimum : " + swarmBestSolution)
		
		if (swarmBestSolution == null) {
			this.swarmBestSolution = occurrence.solution
		} else if (occurrence.solution < swarmBestSolution) {
			this.swarmBestSolution = occurrence.solution			
		}
		
		waitTask.every(1000) [
			info("Wait for move! 1")
					emit(new AskForMove(this.ID))
		]
	}

	on WaitForMove {
		waitTask.cancel()
		info("Wait for Move")

		waitTask.every(1000) [
			info("Wait for move! 2")
					emit(new AskForMove(this.ID))
		]
	}

	on AutoriseToMove {
		waitTask.cancel()
		info("Start Move")
		Move()

		waitTask.every(1000) [
			info("Wait for")
			emit(new HasMoved(this.ID))
		]
	}

	def Move() {
		 var newVelocity : Vector2f
	
		 var b1 = random.nextFloat() * phi1;
		 var b2 = random.nextFloat() * phi2;
		 var currentPosition = new Vector2f(this.x.value, this.y.value)
		
		 newVelocity = (currentVelocity * inertie) + (ownBestSolution.position - currentPosition) * b1
		 if (swarmBestSolution != null)
		 newVelocity += (swarmBestSolution.position - currentPosition) * b2
		
		 x.set(x.value + newVelocity.x)
		 y.set(y.value + newVelocity.y)		
	}
//	on StartLive {
//		emit(new GetValue(this.x.value, this.y.value))
//
//	}
//
//	on ReturnedValue {
//		if (isMe(occurrence.destination)) {
//			var sol = occurrence.solution as Solution
//			if (ownBestSolution == null) {
//				this.ownBestSolution = sol
//			} else if (sol.value < ownBestSolution.value) {
//				this.ownBestSolution = sol
//				emit(new OptimumLocalFound(ownBestSolution))
//			}
//			in(1000) [
//				Move()
//				emit(new ParticleSpawned)
//			]
//		}
//	}
//
//	on GlobalOptimumFound {
//		this.swarmBestSolution = occurrence.sol
//	}
//
	
}